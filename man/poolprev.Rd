% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/poolprev.R
\name{poolprev}
\alias{poolprev}
\title{Estimate prevalence from pooled test results}
\usage{
poolprev(
  data,
  method = "GP",
  spec = 0.995,
  prior = NULL,
  return.par = FALSE,
  return.stanfit = FALSE,
  ...
)
}
\arguments{
\item{data}{Datasets with the following variables:

\itemize{
\item time. Time (should be numeric)
\item pop. Population name (if missing, it assumes an unique population to analyse)
\item pool.size. Pool size (number of samples by pool)
\item n.pools. Number of pools
\item n.pos.pools. Number of positive pools.
}}

\item{method}{Method used to analyse data (timepoint or GP)}

\item{spec}{Test specificity}

\item{prior}{list of values for prior hyperparameters.}

\item{return.par}{a logical indicating whether to return GP parameter estimates.}

\item{return.stanfit}{a logical indicating whether to return the stan model.}

\item{...}{Arguments passed to \code{rstan::sampling} (e.g. iter, chains). If there are divergences,
add \code{control=list(adapt_delta=0.99)}.}
}
\value{
A list containing the following elements:
\itemize{
\item prev. A data frame displaying estimated prevalence over time (and populations).
\item prev_ratio. Ratio between two consecutive prevalence estimates.
\item mod_par. Estimates of some model parameters (returned if \code{return.par} is \code{TRUE}).
\item sampler_par. Stan diagnosis parameters (returned if \code{return.par} is \code{TRUE}).
\item time. Stan sampling time (returned if \code{return.par} is \code{TRUE}).
\item stanfit. \code{stanfit} object (returned if \code{return.stanfit} is \code{TRUE}).
}
}
\description{
\code{poolprev} is used to estimate prevalence from pooled test results over time.
It fits a Bayesian model using the Stan framework.
}
\details{
Two models are implemented, which differ in the way the correlation over time is handled.
In the default model (selected by setting \code{method="GP"}), a hidden Gaussian process (GP) model the true prevalence in order to take the correlation over time into account.
The \code{GP} method uses a squared exponential kernel to characterize the correlation of the GP.
This basically assumes that the correlation between the prevalence of two timepoints only depends on the distance between the timepoints (i.e. the time difference). fit two parameters $\lambda$
Two parameters are used to model the squared exponential kernel (also known as "exponentiated quadratic kernel"): the lengthscale $\lambda$ and the output variance $\alpha^2$.
The lengthscale $\lambda$ determines the length of the "wiggles".
The output variance $\alpha^2$ is a scale factor that determines the average distance between the realizations of the GP.
It characterizes the variance of the prevalence over time.

The second (more basic) model (selected by setting \code{method="timepoint"}) estimates the prevalence at each timepoint without considering any correlation over time.
It assumes one parameter for each timepoint in order to estimate the prevalence over time.
The \code{timepoint} model is provided for the sake of comparison but the \code{GP} model should generally be preferred.

The models adjust for imperfect sensitivity and specificity.
They assume a default fixed specificity of 99.5\% (can be modified through the \code{spec} argument).
The sensitivity is fitted together with the prevalence parameters by using the data reported in Bendavid et al. (2020), which includes 3 sensitivity studies.

The models calculate the pool test positivity over time from the prevalence (and the pool sizes \code{pool.size} given in \code{data}).
It assumes that the number of positive pools \code{n.pos.pools} follow a binomial distribution : $\text{n.pos.pools}\sim Binomial(\text{n.pool},\text{"pool positivity"}).

When multiple pooled test results are provided for at least one timepoint (for the same population), the model replace the binomial distribution a beta-binomial distribution.
Overdispersion is characterized with the $\kappa$ parameter.

If the \code{pop} column in the \code{data} argument is absent, the model assumes only one population (i.e. it models one prevalence over time).
If it is provided, the models estimate the prevalence over time for each of the populations present in \code{data}.
This allows for a unique (and simultaneous) estimation of the sensitivity.
The user should however consider running the populations separately, if some issues about the convergence of the Stan model are observed.
}
\examples{
#Example 1
#load data
data(epipool_data1)

#run model with method assuming a prevalence parameter every week
out_timepoint = poolprev2(epipool_data1[[1]], method="timepoint", return.par=TRUE,return.stanfit=FALSE) #takes a few seconds
#run model with Gaussian process
out_GP = poolprev2(epipool_data1[[1]], method="GP", return.par=TRUE,return.stanfit=FALSE) #can take a few minutes

#plot
library(ggplot2)
library(dplyr)
dplyr::left_join(epipool_data1[[1]],
          rbind(out_timepoint$prev \%>\% dplyr::mutate(method="timepoint"),
                out_GP$prev \%>\% dplyr::mutate(method="GP")),
          by="time") \%>\%
  ggplot(aes(x=time))+
  geom_ribbon(aes(ymin=lwr,ymax=upr),fill="black",alpha=0.1)+
  geom_line(aes(y=mean),col="black",size=0.8)+
  geom_point(aes(y=mean),col="black",size=2)+
  geom_point(aes(y=prev),col="red",size=2) +
  facet_grid(.~method) +
  theme_bw() +
  scale_y_continuous(name="Prevalence", labels = scales::percent)

#Example 2: estimate the prevalence of two populations
#load data
data(epipool_data2)
data(epipool_data3)
data = rbind(epipool_data2[[1]] \%>\% dplyr::mutate(pop="pop1"),
            epipool_data3[[1]] \%>\% dplyr::mutate(pop="pop2"))

#run model with GP
out_timepoint = poolprev2(data, method="timepoint", return.par=TRUE) #takes a few seconds
out_GP1 = poolprev2(data, method="GP", return.par=TRUE) #can take a few minutes
out_GP2 = poolprev2(data, method="GP",prior=list(lengthscale=c(0,1),sd_GP=c(0,1)),
                     return.par=TRUE) #can take a few minutes

#plot prevalence
library(ggplot2)
left_join(data,
          rbind(out_timepoint$prev \%>\% dplyr::mutate(method="timepoint"),
                out_GP1$prev \%>\% dplyr::mutate(method="GP"),
                out_GP2$prev \%>\% dplyr::mutate(method="GP with smaller lengthscale/sd priors")), by=c("time","pop")) \%>\%
ggplot(aes(x=time))+
geom_ribbon(aes(ymin=lwr,ymax=upr),fill="black",alpha=0.1)+
geom_line(aes(y=mean),col="black",size=0.8)+
geom_point(aes(y=mean),col="black",size=2)+
geom_point(aes(y=prev),col="red",size=2) +
facet_grid(method~pop) +
theme_bw() +
scale_y_continuous(name="Prevalence", labels = scales::percent)

#compare parameter estimates
print(out_timepoint$par)
print(out_GP1$par)
print(out_GP2$par)
}
